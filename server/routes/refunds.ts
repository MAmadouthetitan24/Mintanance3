import express, { Request, Response } from 'express';
import Stripe from 'stripe';
import { storage } from '../storage';
import { isAuthenticated } from '../replitAuth';
import { sendNotification } from '../services/notifications';
import { PaymentInfo } from '@shared/schema';

const router = express.Router();

interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    name: string;
    isAdmin?: boolean;
    role: string;
  };
}

// Initialize Stripe
const stripe = process.env.STRIPE_SECRET_KEY
  ? new Stripe(process.env.STRIPE_SECRET_KEY, { apiVersion: '2025-04-30.basil' })
  : null;

// Request a refund
router.post('/jobs/:id/refund-request', isAuthenticated, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    if (!stripe) {
      res.status(500).json({ error: 'Stripe is not properly configured' });
      return;
    }

    const { id: jobId } = req.params;
    const { reason } = req.body;
    const user = req.user;

    if (!user) {
      res.status(401).json({ error: 'User not authenticated' });
      return;
    }

    // Get job details
    const job = await storage.getJob(parseInt(jobId));
    if (!job) {
      res.status(404).json({ error: 'Job not found' });
      return;
    }

    // Verify user owns the job
    if (job.homeownerId !== user.id) {
      res.status(403).json({ error: 'Not authorized to request refund for this job' });
      return;
    }

    // Check if payment exists and is completed
    const paymentInfo = job.paymentInfo as PaymentInfo | undefined;
    if (!paymentInfo?.transactionId || job.paymentStatus !== 'completed') {
      res.status(400).json({ error: 'No completed payment found for this job' });
      return;
    }

    // Get the payment record for this job
    const payment = await storage.getPaymentByJobId(parseInt(jobId));
    if (!payment) {
      res.status(400).json({ error: 'No payment record found for this job' });
      return;
    }

    // Create refund request
    const refundRequest = await storage.createRefundRequest({
      jobId: parseInt(jobId),
      userId: user.id,
      paymentId: payment.id,
      paymentIntentId: paymentInfo.transactionId,
      reason,
      status: 'pending',
      amount: job.actualCost || job.estimatedCost || 0,
      error: null,
      refundId: null,
      rejectionReason: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      processedAt: null,
      id: 0, // This will be auto-generated by the database
    });

    // Notify admin about refund request
    await sendNotification('admin', {
      type: 'payment',
      title: 'New Refund Request',
      message: `A refund has been requested for job #${jobId}`,
      data: { jobId, refundRequestId: refundRequest.id },
    });

    res.json({ success: true, refundRequest });
  } catch (error) {
    console.error('Error requesting refund:', error);
    res.status(500).json({ error: 'Failed to request refund' });
  }
});

// Process refund (admin only)
router.post('/refund-requests/:id/process', isAuthenticated, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    if (!stripe) {
      res.status(500).json({ error: 'Stripe is not properly configured' });
      return;
    }

    const { id: refundRequestId } = req.params;
    const { approved, reason } = req.body;
    const user = req.user;

    if (!user) {
      res.status(401).json({ error: 'User not authenticated' });
      return;
    }

    // Verify user is admin
    if (user.role !== 'admin') {
      res.status(403).json({ error: 'Only admins can process refunds' });
      return;
    }

    // Get refund request
    const refundRequest = await storage.getRefundRequest(parseInt(refundRequestId));
    if (!refundRequest) {
      res.status(404).json({ error: 'Refund request not found' });
      return;
    }

    if (refundRequest.status !== 'pending') {
      res.status(400).json({ error: 'Refund request has already been processed' });
      return;
    }

    if (approved) {
      // Process refund through Stripe
      const refund = await stripe.refunds.create({
        payment_intent: refundRequest.paymentIntentId,
        reason: 'requested_by_customer',
      });

      // Update refund request status
      await storage.updateRefundRequest(parseInt(refundRequestId), {
        status: 'approved',
        processedAt: new Date(),
        refundId: refund.id,
      });

      // Update job status
      await storage.jobs.update({
        where: { id: refundRequest.jobId.toString() },
        data: {
          paymentStatus: 'refunded',
          status: 'cancelled',
          updatedAt: new Date(),
          paymentInfo: {
            transactionId: refundRequest.paymentIntentId,
            amount: refundRequest.amount,
            currency: 'usd',
            status: 'refunded',
            method: 'stripe',
            refundId: refund.id,
          } as PaymentInfo,
        },
      });

      // Notify user
      await sendNotification(refundRequest.userId, {
        type: 'payment',
        title: 'Refund Approved',
        message: `Your refund request for job #${refundRequest.jobId} has been approved`,
        data: { jobId: refundRequest.jobId, refundId: refund.id },
      });
    } else {
      // Update refund request status to rejected
      await storage.updateRefundRequest(parseInt(refundRequestId), {
        status: 'rejected',
        processedAt: new Date(),
        rejectionReason: reason,
      });

      // Notify user
      await sendNotification(refundRequest.userId, {
        type: 'payment',
        title: 'Refund Rejected',
        message: `Your refund request for job #${refundRequest.jobId} has been rejected: ${reason}`,
        data: { jobId: refundRequest.jobId },
      });
    }

    res.json({ success: true });
  } catch (error) {
    console.error('Error processing refund:', error);
    res.status(500).json({ error: 'Failed to process refund' });
  }
});

export default router; 